锁，顾名思义就是锁住一些资源，当只有我们拿到钥匙的时候，才能操作锁住的资源

### **公平锁与非公平锁**

公平锁:指线程在等待获取同一个锁的时候，是严格按照申请锁的时间顺序来进行的，这就意味着在程序正常运作的时候，不会有线程执行不到，而被“饿死”，但是也需要额外的机制来维护这种顺序，所以效率相对于非公平锁会差点。

非公平锁：概念跟“公平锁”恰恰相反，随机线程获取锁，效率相对高。

```
new ReentrantLock(); //默认非公平锁
new ReentrantLock(true); //公平锁
```

### **重入锁(递归锁)与不可重入锁（自旋锁）**

这里要注意了，重入/递归，不可重入/自旋，虽然名字不同，但是确实是同一种锁，只是从锁的表现跟实现方式的角度来命名而已。

重入锁：当一个线程获取了A锁以后，若后续方法运行被A锁锁住的话，当前线程也是可以直接进入的。

```
public class Demo {
  private Lock lockA;
 
  public Demo(Lock Lock) {
    this.lockA = lock;
  }
 
  public void methodA() {
    lockA.lock();
    methodB();
    lockA.unlock();
  }
 
  public void methodB() {
    lockA.lock();
    //dosm
    lockA.unlock();
  }
  
  }
复制代码
```

当我们运行methodA()的时候，线程获取了lockA，然后调用methodB()的时候发现也需要lockA，由于这是一个可重入锁，所以当前线程也是可以直接进入的。在java中，synchronized跟ReetrantLock都是可重入锁。

不可重入锁：以上面的代码实例来说明，就是methodA进入methodB的时候不能直接获取锁，必须先调用unLock释放锁。才能执行下去，那实现不可重入锁有什么方式呢？那就是自旋，所以会有一个小名叫做自旋锁。

```
public class SpinLock {

  private AtomicReference<Thread> sign =new AtomicReference<>();

  public void lock(){
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current)){
    }
  }

  public void unlock (){
    Thread current = Thread.currentThread();
    sign .compareAndSet(current, null);
  }
}
复制代码
```

### **“悲观锁”与“乐观锁”**

这两种锁呢，其实是一个很宏观的分类，它不是一种具体的锁，而是泛指看待并发的程度。

悲观锁：有一个“悲观”的心态，既每次取数据的时候，都会认为该数据会被修改，所以必须加一把锁才安心。

乐观锁：乐观的孩子，认为同一个数据不会发生并发操作的行为，所以取的时候不会加锁，只有在更新的时候，会通过例如版本号之类的来判断是否数据被修改了。

Java中各种锁其实都是悲观锁的实现，既操作的数据的都会被获取锁的线程锁住，而乐观锁的话，一般是通过cas（compare and swap）的思想来实现，例如一些原子类AtomicInteger使用自旋来原子更新。

### **“共享锁”与“排他锁”**

这两种锁的概念比较多的出现在数据库的事务当中。

共享锁：也称读锁或S锁。如果事务对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。在java中的ReetrantReadWriteLock()也是如此。

排它锁：也称独占锁、写锁或X锁。如果事务对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。

### **分布式锁**

我们上面聊的这些锁，都是在单个程序上面的不同线程之间来实现的，那么当我们的不同程序需要去竞争同一块资源的时候，这就需要分布式锁了，我们可以通过redis、zookeeper等中间件来实现分布式锁。

### 偏向锁

### 轻量级锁

### 自旋锁

自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区，线程尝试获取锁的过程不会阻塞