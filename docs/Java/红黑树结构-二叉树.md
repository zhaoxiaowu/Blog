## 查找算法： 

遍历：o(n)

二分：有序

![image-20200511170626961](..\images\image-20200511170626961.png)

二叉树：二叉树是每个结点最多有两个子树的树结构

二叉查找树： 左  < 父 <右

​				时间复杂度：最坏的情况n/2,n/4,n/8  ..一直到1       得2^x = n     x=lgn s

![image-20200511231732027](..\images\image-20200511231732027.png)

不变成一个链条



**红黑树：**高效的查找算法（特殊的二叉查找树）

链表->二叉树->二叉查找树->特殊的二叉查找树（自平衡二叉查找树）

**性质：**

1.每个节点不是红色 就是 黑色

2.不可能有连在一起的红色节点

3.根节点是黑色

4.每个红色节点的两个子节点都是黑色。叶子节点都是黑色；出度为0 满足性质    就可以达到近似平衡（不会退化为链表）

为了满足红黑树的性质，因此出现了旋转

红黑树的几种变化规则：

1.改变颜色

2.左旋  

![image-20200511203716912](..\images\image-20200511203716912.png)

![image-20200511203653781](..\images\image-20200511203653781.png)



3.右旋

![image-20200511203813508](..\images\image-20200511203813508.png)



![image-20200511203842592](..\images\image-20200511203842592.png)

![image-20200511214227621](..\images\image-20200511214227621.png)

![image-20200511230935841](..\images\image-20200511230935841.png)

旋转 和 颜色变化规则：所有插入的点默认为红色

1.变颜色情况 当前节点的父亲节点是红色，且它的祖父节点的另一个子节点也是红色

（1）.把父节点设为黑色

（2）.把叔叔节点也设为黑色 

（3）.把爷爷节点设为红色

（4）.把指针设置为爷爷节点，分析点的变换规则

2.左旋：当前父节点是红色，叔叔 是黑色的时候，当前节点是右子树。左旋以父节点作为左旋

3.右旋：把当前父节点是红色，叔叔是黑色的时候，且当前的结点是左子树，右旋

（1）.把父结点变为黑色

（2）.把爷爷节点变成红色

（3）.以爷爷节点旋转



平衡树(AVL树)：左右子树都为平衡树，它的左右子树高度差不超过1



哈希（最高效）：0（1） **   哈希冲突           jdk1.8:数组 +链表/红黑树（解决hash冲突）

索引：搜索引擎



**B+树：**

B-树:



书籍：刘汝佳的算法入门经典

​			小辉的算法之旅   

​			数据结构 严蔚敏

​			大话数据结构



![image-20200512002741822](..\images\image-20200512002741822.png)

![image-20200512002953919](..\images\image-20200512002953919.png)

![image-20200512003030094](..\images\image-20200512003030094.png)