# MYSQl架构和历史

## MYSQL逻辑架构

![image-20200706104905207](E:\BLOG\learning\docs\images\image-20200706104905207.png)

最上层并不是mysql独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等。

第二层架构是mysql核心服务功能。包括查询解析、分析、优化、缓存以及所有的内置函数（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等

第三层包含了存储引擎。存储引擎负责mysql中数据的存储和提取。

#### 优化与执行

MYSQL会解释查询，并在内部构建解析树，然后对其进行各种优化

包括：重写查询，决定表的读取顺序  选择合适的索引

## 并发控制

### 读写锁

共享锁和排他锁也叫读锁和写锁

读锁是共享 多个用户可以在同一时刻读取同一个资源

写锁是排他的  也就是说一个写锁会阻塞其它写锁和读锁

MYSQL会通过锁定防止其他用户读取同一数据

### 锁粒度

提高并发性的方式 是让锁定对象更具有选择性   尽量只锁定部分数据

锁定的数据量越小，并发程度越高



加锁需要消耗资源，锁的各种操作票，包含获得锁，检查锁，释放锁都会增加系统的开销。

所谓的锁策略 就是在锁的开销和数据安全性之间追求平衡。

#### 表锁

开销最小，它会锁定整张表。一个用户对表进行写操作  会先获得写锁   这样会阻塞其它用户对该表的所有读写操作

#### 行级锁

可以很大程度 支持并发操作 （同时带来最大的锁开销）

行级锁只在存储引擎层实现

## 事务

一组原子性的SQL语句集

ACID

### 隔离级别

### 死锁

死锁是指两个或两个以上的事务在同一资源相互占有，并请求锁定对方占有的资源  导致恶性循环的现象

**死锁检测机制  和 死锁超时机制**

超时放弃锁请求 这种方式不太好

Innodb  将持有最少行级锁的事务进行回滚

### 事务日志

事务日志可以帮助提高事务的效率。使用事务日志我们修改数据时只需要修改内存拷贝，再将该行为记录到硬盘的事务日志。最后再后台刷回磁盘  我么们称之为Write Ahead log，修改数据需要写入两次磁盘

为什么快？  应为日志操作时一小块区域内的顺序I/O  而不是随机I/O需要磁盘的多个地方移动磁头

### MySQL中的事务

**自动提交**

一些命令 在执行之前会强制执行commit提交当前事务  如AlTER TABLE

**在事务中混合使用了存储引擎**

如果需要回滚，非事务型无法撤销

**隐式或显式锁定**

InnoDB采用的是两阶段锁定协议，在事务执行过程中    随时可以执行锁定，锁只有执行COMMIT或者ROLLBACK的时候才会释放

Innodb会根据隔离级别 自动加锁

显式锁定

SELECT ...LOCK IN SHARE MODE

SELECT ...FOR UPDATE

## 多版本并发控制

大多数事务型存储引擎 都不是简单的 行级锁    基于提升并发的考虑，他们一般同时实现了多版本并发控制（MVCC）



MVVC是行级锁的变种  很多情况避免了加锁操作，开销更低。

MVVC是通过保存数据在某个时间点的快照来实现的。    典型的有乐观锁 并发并发控制 和悲观并发控制



InnoDB的MVCC 是通过在每行记录两个隐藏的列来实现。一个保存创建时间  一个保存删除时间  并不是实际的时间值  

而是系统版本号。 每开始一个新的事务，系统版本号都会递增。用来和查询到的版本号进行比较。

![image-20200706183919755](E:\BLOG\learning\docs\images\image-20200706183919755.png)

## MySQL的存储引擎

### Innodb

- innodb数据存在在表空间（tablespace）中，表空间是由InnoDB管理的一个黑盒子，有一系列的数据文件组成。

默认隔离级别REPEATABLE READ（可重复读） 通过间隙锁  策略防止幻读的出现。

- 采用MVCC支持高并发

- 表是通过聚类索引创建的，其他索引必须包含主键值 主键值很大的话 ，所有索引都会很大 索引较多的话，主键应当尽可能小。

- 存储文件是平台独立的，可以进行迁移。

- 做了很多优化，包括从磁盘读取数据采用的可预测性预读，能够自动在内存中创建hash索引，加快查找速度，以及加入插入缓冲区

- Innodb 可以支持热备份

  

### MyISAM存储引擎

不支持事务，不支持奔溃后的安全恢复

**压缩表**： 导入数据以后，不会再进行修改操作



减少磁盘I/O 从而提高查询

### 如何选用引擎

全文索引  优先使用Innodb +Sphinx(高性能SQL全文检索引擎) 而不是 MyISAM

**事务**

**备份**

**崩溃恢复**

**特有特性**   

MyISAM支持空间地理搜索

# MySQL基准测试

sysbench基准测试工具

## 基准测试的策略

系统的整体测试

单独测试MySQL

##  测试指标                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

吞吐量        响应时间或者延迟      并发性   可扩展性   



//TODO

# 服务器性能刨析

- 定义性能最好的方法就是响应时间

如果是想提升服务器的总体性能，那么比较好的方法是将查询记录到日志中  然后利用pt_query_digest工具生成系统级别的刨析报告。

Show profile 是mysql提供的 分析sql语句  执行资源消耗情况的工具。

explain

# Schema与数据类型优化

反范式的设计可以加快某些类型的查询，但同时可以使另外一些类型的查询变慢。

添加计数表和汇总表是很好的优化查询的方法，但这些表的维护成本页很高。

## 选择优化的数据类型

**选择正确存储最小的数据类型**

**简单最好**

整型 比 字符串操作代价更低

使用整形存储IP地址

**避免NULL**

NULL是列的默认属性，通常情况最好指定为NOT NULL 除非真的需要NULL值

包含NULL的值 对MySQL更难优化   使得索引、索引统计和值都更复杂

当NULL为索引 需要额外的存储空间



TIMESTAMP只使用DATETIME一半的存储空间  并且会根据时区变化    时间范围小

### 整型类型

TININT 8   SMALLINT 16  MEDIUMINT  24   INT   32    BIGINT  64

UNFSIFNED 表示无符号



可以指定宽度INT(11)  但存储和计算没意义  只是MYSQL客户端用来显示字符的个数

### 实数类型

 带有小数部分的数字  FLOAT DOUBLE  DECIMAL

CPU不直接对DECIMAL计算          浮点运算更快

只指定数据类型  不指定精度

因为需要空间和计算开销，所以尽量只是在小数进行精确时才使用DECIMAl



当数据量大的时候 可以用BIGINT代替DECIMAL    

### 字符串类型

VARCHAR CHAR   

`VARCHAR` 可变长度  需要1 或者2个额外字节记录长度

UPDATE的时候  比原来长  INNODB会采用分裂页的方式 使行可以放到页中

场景：

最大长度比平均长度大得多

列的更新很少 ，所以碎片不是问题

UTF-8 每个字符使用不同的字节数进行存储

过长的VARCHAR存储为BLOB

`CHAR`

适合存储短字符串，或者值接近一个定长的值  CHAR不容易产生碎片

密码的MD5值，

BINARY  VARBINARY 它存储的使二进制字符串

### BLOD和TEXT类型

blod 二进制    text 字符

innodb会有专门 外部的存储区域存储  每个值在行内需要1-4个字节存储一个指针

blod存储的二进制  没有排序规则 和 字符集

排序：值排序前面的一部分字符

避免使用  在BLOD字段的地方都使用SUBSTRING(column,length)

### 使用ENUM代替字符串类型

会把每个值在列表的位置保存为整数，并且在表.frm文件保存 字符串-数字映射关系的查找表

避免使用ENUM作为常量。导致双重性混乱

![image-20200708153015870](E:\BLOG\learning\docs\images\image-20200708153015870.png)



### 日期和时间

 DATETIME 

TIMESTAMP   依赖时区  1970-2038  效率高



### 位数据类型

**BIT**

BIT最大长度64位

MYSQL吧BIT当作字符串类型 而不是数字类型

尽量避免使用BIT  如果要保存TRUE/FALSE  可以使用CHAR(0)   

**set**

**在整数列上进行按位操作**

替代set

### 选择标识符

整性比较好

字符串效率不好   例如MD5  生成的值会分布在较大的空间

UUID去掉 "-"   或者更好的做法  用UNHEX() 函数转化UUID为16字节数字  并存储在一个BINARY(16)列中 ，检索时通过HEX() 转化为16进制



**当心自动生成的schema**

### 特殊类型数据

IPV4地址 其实是32位无符号整数   不是字符串  

MSYQL提供 INET_ATON     INET_NTOA函数表示这两种方法之间的转化·

## Schema设计中的陷阱

**太多的行**

服务层 和 存储引擎之间 通过行缓冲格式 拷贝数据

**太多的关联**

单个查询最好在12个表内做关联

**过度使用枚举**

## 范式和反范式

**第一范式：要求数据库表的每一列都是不可分割的原子数据项。**

**第二范式：需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）**

**第三范式：需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

范式设计的缺点：需要关联

单表性能要快，避免了随机I/O

### 混用范式和反范式

最常用的反范式数据的方法 是复制或者 缓存

触发器更新缓存值

从父表冗余一个字段  但更新的时候 就需要同时更新两张表

缓存衍生中  比如统计用户发了多少条消息  把值存下来

## 缓存表和汇总表

汇总表：从其他表汇总   计算最活跃的用户 或者最常见的标签

缓存表： 可以比较简单地从其他表获取 

要决定是实时维护数据 还是定期重建    

定期重建会节省资源，不会有碎片  顺序组织的索引更高效



保证数据在操作时依然可用 需要影子表

![image-20200708184009292](E:\BLOG\learning\docs\images\image-20200708184009292.png)

#### 物化视图

是预先计算并存储在磁盘上的表

#### 计数器表

cnt

增加并发

增加100条记录

随机slot 更新  

## 加快ALTER TABLE的速度

创建一个新表 从旧表查出所有的数据插入新表 然后删除旧表，这样操作可能 会花费很长时间。

一、在一台不提供服务的机器上执行ALTER TABLE操作，然后提供主库进行切换

二、影子拷贝，创建新表  然后通过重命名 和 删库 操作交换两张表

ALTER COLUMN操作来改变列的默认值  这个语句会直接修改.frm文件而不涉及表数据



### 只修改.frm文件文件

**总结：**

- 避免过度设计

- 使用小而简单的数据类型   尽量避免null值

- 注意可变长字符串  临时表或排序时  导致悲观的分配最大长度

- 使用整性作为标识符

- 小心使用ENUM SET  最好避免使用bit

  反范式也是必需的   

  AlTER TABLE 大部分情况会锁表 或者 重建整张表

# 创建高性能的索引

索引是快速查找的一种数据结构 使查询提高几个数量级

索引对于良好的性能非常关键  当数据量逐渐增大，不合适的索引 会使性能急剧下降

索引类似书的目录

## 索引的类型

索引是在存储引擎层 而不是 服务器层

**B- 索引** 

**hash索引**    基于哈希表  只有精准匹配才有效   

Innodb  自适应哈希索引， 当某些索引值被使用的非常频繁，它会在内存中给予B树索引之上  再创建一个 哈希索引

**空间数据索引（R - Tree）**         **全文索引**

## 索引的优点

还可以用来做  ORDER BY   GROUP   BY操作   应为数据是有序的  、

1.索引大大减少了服务器需要扫描的数据量。

2.索引大大帮助服务器避免排序和临时表

3.索引可以将随机I/O 变为顺序I/O

## 高性能的索引策略

### 独立的列

不能是表达式的一部分，也不能是函数的参数

### 前缀索引和索引的选择性

索引很长的字符串，这样会让索引变的大且慢   一个策略是模拟哈希索引

也可以索引开始的部分字符 节约空间  提高效率

**选择前缀索引**

![image-20200709235818106](E:\BLOG\learning\docs\images\image-20200709235818106.png)

前缀索引无法order by 或者group by

一个场景是  16进制唯一Id做索引   长度为8的前缀索引能明显提高性能

### 多列索引

在多个列建立独立的单索引大部分情况并不能提高MYSQL的查询性能

索引合并策略是一种优化结果，但更多时候说明索引建的糟糕

- 当出现多个列做相交操作（通常多个AND条件），通常以为需要一个包含所有相关列的多列索引，而不是多个独立的单列索引
- 当出现多个列做联合操作（通常多个OR条件）,消耗大量的资源再缓存、排序和合并操作上    将查询改为union的方式更好

### 选择合适的索引列的顺序

索引列的顺序 意味着 索引按照最左列进行排序

选择型最高的索引放到最前列  但通常不如避免随机I/O和排序重要

当不需要考虑排序和分组时  将选择性最高的列放到最前面通常是最好的

可能需要根据运行频率最高的查询来调整索引列的顺序

![image-20200710123842286](E:\BLOG\learning\docs\images\image-20200710123842286.png)

这样的结果依赖选定的具体值   对其他一些条件值不公平

![image-20200710125104940](E:\BLOG\learning\docs\images\image-20200710125104940.png)



![image-20200710130734448](E:\BLOG\learning\docs\images\image-20200710130734448.png)

### 聚簇索引

一个表只能有一个聚簇索引  主键作为聚簇索引 

如果没有主键   会选择一个唯一非空索引     还没有会隐式定义一个主键作为聚类索引

**优点**：

- 可以把相关数据放到一块
- 访问根快    索引和数据保存 在一个B树里

**缺点：**

- 插入速度严重依赖于插入顺序
- 更新代价高
- 插入新行 或者主键被更新  可能导致页分裂
- 可能导致全表扫描变慢
- 二级索引需要两次查找

### 在聚类索引按照主键顺序插入行

最简单使用AUTO_INCREMENT自增列  这样可以保证数据的顺序写入

最好避免随机的（不连续且值的分布范围非常大）聚簇索引

UUID作为聚簇索引性能很糟糕

![image-20200710165809609](E:\BLOG\learning\docs\images\image-20200710165809609.png)

### 覆盖索引

覆盖索引：索引包含所需要查询的字段的值

哈希索引  空间索引  覆盖索引都不存存储索引列的值

EXPLAIN的   Extra可以看到Using index的消息 

**![image-20200710172741338](E:\BLOG\learning\docs\images\image-20200710172741338.png)**

无法使用覆盖索引

![image-20200710173746108](E:\BLOG\learning\docs\images\image-20200710173746108.png)

这种方式叫做延迟关联，因为延迟队列的访问。

先使用覆盖索引查到第一层 ，然后在子句中查找所需要的列值

**5.6 索引条件推进**

### 使用索引扫描排序

mysql有两种方式可以生成有序的结果；通过排序操作，或者按索引顺序扫描

如果EXPLAIN出来type 列是 index 则说明索引扫描来做排序

**设计索引及即满足排序又可以用来查找行**

索引扫描很快，但如果索引不能覆盖所需的全部列，那就不得每扫描一个索引记录都回表一次

这基本上是随机I/O 这样比顺序的全表扫描慢

### 压缩索引

### 冗余和重复索引

使用冗余索引 查询变快  但插入慢

### 未使用的索引

### 索引和锁

索引可以让查询锁定更少的行

但也可能锁住不需要的行

## 索引案例学习

### 支持多种过滤查询

那些列在where子句中出现的最频繁，在有更多不同值上创建索引的选择性会更好

尽可能把范围查询放到索引的后面

### 避免多个范围条件

多个范围查询  业务方法

### 优化排序

![image-20200710230120321](E:\BLOG\learning\docs\images\image-20200710230120321.png)

### 维护索引和表

#### 更新索引统计信息

#### 减少索引和数据的碎片

行碎片

行间碎片

剩余空间碎片

OPTIMIZE TABLE或者导出再导入重新整理数据

### 总结

1. 尽可能选择合适的索引避免单行查找
2. 尽可能使用数据原生顺序从而避免额外的排序操作
3. 尽可能使用索引覆盖查询

理解索引的工作十分重要：而不是`在多列索引中将选择性最高的放到第一列`

或者  `应该为WHERE子句中出现的所有列创建索引`  经验法则及其推论



判断索引是否合理？ 根据响应时间消耗较长的查询 

# 查询性能优化

## 慢查询基础：优化数据访问

大量性能低下的查询都需要减少访问数据量的方式：

- 确定应用程序是否检索大量超过需求的数据
- 确定服务器是否在分析大量超过需求的数据行

### 是否向数据库请求了不需要的数据

**查询不需要的记录**

**多表关联返回全部列**

**总是取出所有列**

**重复查询相同的内容**

### MYSQL是否扫描额外的记录

*衡量查询开销：*

响应时间             扫描的行数        返回的函数

#### 扫描的行数和访问类型

EXPLAIN type列出了访问类型

[mysql中explain的type的解释](https://blog.csdn.net/dennis211/article/details/78170079)

| type   | 解释                                               |
| ------ | -------------------------------------------------- |
| all    | 全表扫描                                           |
| index  | 索引扫描（不一定比全表扫描快）回表随机取数据       |
| range  | 范围查找                                           |
| ref    | 索引列的有重复，还需要在小范围查找                 |
| ref_eq | 用于联表查询的情况，按联表的主键或唯一键联合查询。 |
| const  | 是直接按主键或唯一键读取                           |

扫描表 扫描索引  范围访问  单值访问

三种方式应用WHERE条件 从好到坏

- 在索引中使用WHERE
- 索引覆盖扫描（Extra using index）  无需回表查询数据
- 从数据表返回结果（Extra  using where）

**扫描大量的数据只返回少数行**

- 使用索引覆盖
- 改变库表结构  使用汇总表
- 重写复杂查询  让MYSQL优化器 更优化地执行这个查询

## 重构查询的方法

### 一个复杂查询还是多个简单查询

### 切分查询

删除旧的数据

大语句一次性完成 锁住很多数据

可以影响性能  减少复制的延迟

### 分解关联查询

- 让缓存效率更高
- 减少锁的竞争
- 更容易对数据库拆分
- 本身查询效率也可能提高
- 减少冗余的记录查询
- 相当于实现哈希关联  而不是MYSQl的嵌套关联

## 查询执行的基础

![image-20200711020112479](E:\BLOG\learning\docs\images\image-20200711020112479.png)

### 通讯协议

半双工  没法流量控制

查询语句很长max_allowed_packet很重要 一旦发送了请求 只能等待

MYSQL的库函数可以获得结果集  并缓存到内存中

### 查询状态

SHOW FULL PROCESSLIST

![image-20200711020933134](E:\BLOG\learning\docs\images\image-20200711020933134.png)

### 查询缓存

通过大小写敏感的哈希查找实现的

命中后 会检查权限

### 查询优化处理

SQL转化为执行计划 再与存储引擎交互

解析SQL 预处理  优化执行后计划

解析SQL：语法是否正确

预处理：是否合法 表是否存在  验证权限

### 查询优化器

找到最好的执行计划

不考虑缓存

**导致错误执行计划的原因**

![image-20200711022544815](E:\BLOG\learning\docs\images\image-20200711022544815.png)

### 数据和索引的统计信息

查询优化器 向搜索引擎 查找对应的统计信息、

### MYSQL如何执行关联查询

对任何关联都执行嵌套循环操作

### 执行计划

MYSQL并不是根据记录来选择最优的执行计划 而是预估需要读取的数据页

straight_join 重写查询

### 排序优化

避免大数据的排序

不使用 索引  称为文件排序（filesort）

如果小于排序缓冲区 在内存使用 快速排序

不够 先将数据分块  然后排序合并

排序算法：

两次传输排序（旧）

读取行指针 和需要排序的字段 进行排序  读取数据行

单次传输排序

先读取查询所需的所有列 再根据给定列排序  最后直接返回结果   适合I/O密集型

临时表空间很大

max_length_for_sort_data 决定排序算法

![image-20200711024929383](E:\BLOG\learning\docs\images\image-20200711024929383.png)

## 查询执行引擎

返回客户端是个增量

## MYSQL查询优化器的局限性

### 关联子查询

where 条件 包含IN的子查询   并不是先计算里面的

EXISTS

###  UNION限制

从临时表取出数据的顺序并不不是一定的  还需要全局的ORDER和LIMIT操作

### 索引的合并优化

MYSQL能够访问单张表的多个索引以合并和交叉过滤的方式来定位查找的行

### 等值传递

等值传递可能带来意想不到的额外消耗

### 并行执行

无法利用多核特性来并行执行查询

### 哈希索引

不支持哈希索引

### 松散索引扫描

可以给前面的列加上可能的常数值

5.6 索引条件下推

### 最大值最小值优化

### 在用一个表上查询和更新

### 查询优化器的提示（hint）

对执行计划不满意  可以使用优化器提供的几个提示（hint）来控制作最终的执行计划

## 优化特定类型的查询

### 优化COUNT查询

![image-20200713105323134](C:\Users\pc-hone\images\image-20200713105323134.png)

### 优化关联查询

![image-20200713105703147](C:\Users\pc-hone\images\image-20200713105703147.png)

### 优化GROUP BY和DISTINCT

### 优化LIMIT分页

offset 过大 扫描大量的行 ，再抛弃    延迟关联  

下一页     还可以根据最新一条记录 向后

![image-20200713111413372](C:\Users\pc-hone\images\image-20200713111413372.png)

汇总表

### 优化UNION存储

最好使用union all  union会给临时表加distinct

### 使用自定义变量

**优化排名语句**

**避免重复查询刚才更新的数据**

 **统计更新和插入数量**

![image-20200713120203078](C:\Users\pc-hone\images\image-20200713120203078.png)

**确定取值的范围**



# MYSQL高级特性

## 分区表

分区表是一个独立的逻辑表，但底层时由多个物理子表组成的。

MySQL在创建表时使用PARTITION BY子句定义每个分区存放的数据。

查询的时候，优化器会自动过滤那些没有我们需要数据的分区

作用：

- 表非常大，无法全部放到内存中，或者表只有最后是热点数据，其它均是历史数据。
- 分区表的数据更容易维护
- 分区表数据可以分布在不同的物理设备上
- 避免某些特殊的瓶颈      例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争
- 可以备份和恢复单个分区



分区字段必须是表上所有的唯一索引包含的字段的子集。

### 分区表类型

[分区表](https://www.cnblogs.com/wy123/p/9778590.html)

分区子句可以使用各种函数，但有一个要求，表达式返回的值要是一个整数。

**根据范围进行分区**

**list分区**

**hash分区**

**key分区**

**columns分区**

### 如何使用分区表

非常大的表查询一段时间的历史记录

索引已经不能解决 B- TREE无法起作用了

分区的话    可以做顺序扫描  或者加索引   或者将数据都缓存到内存

**查询扫描数据，不要任何索引**

扫描的分区放到一个小的数量

**索引数据，并分离热点**

### 问题

null值会使分区过滤失败     使用range columns

分区列 和 索引列不匹配

选择分区的成本可能大

打开或者所著所有底层表的成本可能很高

分区维护成本高

### 查询优化

分区可以查询扫描更少的数据

对于分区表，重要的一点带上分区列 即使看起来是多余的   不能使用函数

### 合并表

## 视图

 视图是一个虚拟表，SQL语句集。

两种方法处理试图：  合并算法  和 临时表算法。 尽可能使用合并算法

![image-20200709085347320](E:\BLOG\learning\docs\images\image-20200709085347320.png)

### 可更新视图

![image-20200709085811922](E:\BLOG\learning\docs\images\image-20200709085811922.png)

### 视图对性能的影响

在MySQL的某些情况下视图可以帮助提高性能。

可以实现基于列的权限控制

视图即使使用合并算法实现--也并不是很优化的实现

### 视图的限制

不支持物化视图  不支持视图创建索引

## 外键约束

外键是有成本的，通常需要在修改操作的时候在另一张表执行查找操作

如果两表始终要一致性数据  那么外键比在应用程序中检查一致性要高得多

外键需要额外的锁。 会对父表记录加锁，  甚至会导致死锁。

可以用触发器代替外键

如果只是外键做约束，在应用程序中实现更好，外键会带来额外的消耗

## MYSQL内部存储代码

 存储过程  函数    可以接收参数 和 返回值 

  触发器   时间

### 存储过程

**优点：**

- 它在服务器内部执行，离数据更近  ，  可以节省带宽和网络延迟

- 可以帮助提升安全 ，比如提供更细粒度的权限控制

- 服务器可以缓存执行计划 反复执行 降低消耗
- 不需要其它依赖

- 更好的分工

**缺点：**

- 很难实现较复杂的逻辑 代码复杂度高

- 部署 带来额外的复杂性

- 给服务器带来额外的压力  可能因为存储过程拖垮整个程序

  希望存储过程越小 越简单越好  复杂逻辑交给上层应用

存储过程应为无需网络通信  解析  优化器  开销  所以会更快

### 触发器

触发器可以让你在执行INSERT UPDATE DELETE时  执行特定的操作

可以在执行前 或执行后触发

优点： 简化应用逻辑 提高性能

可以自动更新反范式数据  或者  汇总表数据

注意：

对于表的每一个事件  只能定义一个触发器

MYSQL 只支持 基于行的触发



使用触发器而不是批量更新的原因 ： 触发器可以保证数据总是一致的

不能保证更新的原子性



触发器可以实现一些约束   系统维护任务   反范式更新   记录数据变更日志

### 事件

线程级别的  执行完会被销毁

GET LOCK 确定当前总有一个事件在执行

CONTINUE HANLDER 来确保出现异常  仍会释放锁

### 存储程序保存注释

客户端会自动过滤注释

技巧使用版本相关的注释

## 游标

服务端提供 只读的，单向的游标



SHOW STATUS 来诊断存储过程

### 绑定变量

## 服务端自定义函数

## 插件

## 字符集和校对

_bin   _ci    _cs

 _ci 结尾的是忽略大小写。

 _bin 结尾的是以二进制比较

_cs 结尾的是考虑大小写。

## 全文检索

## 分布式事务

XA中需要一个事务协调器来保证所有的事务参与者都完成了准备工作。如果协调器收到都准备好的消息   就会告诉所有事物可以提交了

### 内部XA事务

二进制日志（复制需要）

推荐使用带电池保护的RAID卡写缓存；这个缓存大大增加了fsync操作的效率

### 外部XA事务

## 查询缓存

缓存查询的执行计划  可以跳过解析  和执行计划生成的阶段。

还可以缓存SELECT查询的结果     会跟踪查询的每个表  如果有变化  就会失效

长时间的事务会大大降低 缓存的命中率

如果查询缓存使用了大量的内存，缓存失效操作就可能成为一个非常严重的问题瓶颈    缓存失效可能使系统僵死

### 查询缓存融合使用内存

除了查询结果，还需要缓存的还有别的维护相关的数据

这些基本管理维护数据结构大概40kb的内存资源

查询缓存被分为一个个的数据快，数据块是变长的

![image-20200709171711406](E:\BLOG\learning\docs\images\image-20200709171711406.png)

### 什么情况查询缓存能起到作用

**缓存未命中的情况**

查询语句无法被缓存  包含不确定的函数（CURRENT_DATE）  

由于之前缓存了查询结果，但是由于查询缓存的内存用完了，MYSQL需要将这些缓存逐出。或者表修改导致缓存失效

MYSQL未处理过这个查询

**大量缓存未命中，其实已经被查询**

查询缓存还未完成预热

缓存失效次数过多     缓存碎片，内存不足，数据修改 都会导致缓存失效

Qcache_hits  和 Qcache_inserts的比值 大于3：1通常查询缓存是有效的   最好能达到10：1

如果没有达到可以考虑禁用查询缓存，除非查询缓存没有成为系统的瓶颈

### 如何配置和维护查询缓存

**query_cache_type**

是否打开查询缓存，可以设置为OFF ON  或DEMAND

DEMAND只有查询语句写明SQL_CACHE的语句才放入查询缓存

**query_cache_size**

查询缓存使用的总内存空间 单位字节

**query_cache_min_res_unit**

分配内存块的最小单位

**query_cache_limit**

如果查询结果大于这个值，则不会被缓存

**query_cache_wlock_invalidate**

如果表被其他连接锁住，是否仍然从查询缓存中返回结果。这个参数默认为OFF

#### 减少碎片

query_cache_min_res_unit 值太小  则浪费空间更小。 但是会导致频繁的内存快申请

值过大，则碎片会很多

### INnoDb 和 查询缓存

大于该表计数器的事务才可以使用查询缓存。

SQL 语句有ON DELETE CASCADE那么相关链表的查询缓存也要一起失效

### 查询缓存的替代方案

客户端缓存

**总结：**

![image-20200709190612099](E:\BLOG\learning\docs\images\image-20200709190612099.png)

![image-20200709190627254](E:\BLOG\learning\docs\images\image-20200709190627254.png)

![image-20200709190639464](E:\BLOG\learning\docs\images\image-20200709190639464.png)

# 优化服务器设置

//TODO

# 操作系统和硬件优化

//TODO

### 复制

//TODO

# 可扩展的MYSQL

# EXPLAIN

获取关于查询计划的信息，以及如何解释输出

可以帮助了解MYSQL优化器是如何工作的

## 调用EXPLAIN

### select type列

 显示复杂查询还是简单查询 最外层标记为primary

subquery  from前

derived   from后

union

union result

### table

访问的那个表  左侧深度优先

### type

### possible_keys

可能使用的索引

### key

数据访问/读取操作类型（All、index、range、ref、eq_ref、const/system、NULL）

### key_len

索引可能的最大长度

### ref

列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

### rows

为了找到所需要的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可初略估算整个查询会检查的行数

### filteed

针对表里符合某个条件的记录数的百分比所作的一个悲观估算

### extra

using index

使用覆盖索引

using where

查询可受益于不同的索引

using temporary

查询结构排序时  会使用临时表

using filesort

对结果使用外部索引排序

Range checked for each record

意味着没有好用的索引

[MySQL 执行计划(Using where,Using index 和 Using index condition)](https://segmentfault.com/q/1010000004197413)

[索引](https://www.cnblogs.com/tufujie/p/9413852.html)

